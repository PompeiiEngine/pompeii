/// Header for the on-disk format generated by astcenc.
struct ASTCHeader
{
	/// Magic value
	uint8_t magic[4];
	/// Block size in X
	uint8_t blockdimX;
	/// Block size in Y
	uint8_t blockdimY;
	/// Block size in Z
	uint8_t blockdimZ;
	/// Size of the image in pixels (X), least significant byte first.
	uint8_t xsize[3];
	/// Size of the image in pixels (Y), least significant byte first.
	uint8_t ysize[3];
	/// Size of the image in pixels (Z), least significant byte first.
	uint8_t zsize[3];
};
static_assert(sizeof(ASTCHeader) == 16, "Packed ASTC header struct is not 16 bytes.");

#define ASTC_MAGIC 0x5CA1AB13

Result loadASTCTextureFromAsset(const char *pPath, vector<uint8_t> *pBuffer, unsigned *pWidth, unsigned *pHeight,
                                VkFormat *pFormat)
{
	vector<uint8_t> compressed;
	if (FAILED(OS::getAssetManager().readBinaryFile(&compressed, pPath)))
	{
		LOGE("Failed to read ASTC texture: %s.\n", pPath);
		return RESULT_ERROR_IO;
	}

	if (compressed.size() < sizeof(ASTCHeader))
		return RESULT_ERROR_GENERIC;

	ASTCHeader header;
	memcpy(&header, compressed.data(), sizeof(ASTCHeader));
	uint32_t magic = header.magic[0] | (uint32_t(header.magic[1]) << 8) | (uint32_t(header.magic[2]) << 16) |
	                 (uint32_t(header.magic[3]) << 24);

	if (magic != ASTC_MAGIC)
	{
		LOGE("Texture %s is not ASTC.\n", pPath);
		return RESULT_ERROR_GENERIC;
	}

	if (header.blockdimZ != 1)
	{
		LOGE("ASTC 3D textures not supported yet in Vulkan.\n");
		return RESULT_ERROR_GENERIC;
	}

	if (header.blockdimX == 4 && header.blockdimY == 4) // 4x4
		*pFormat = VK_FORMAT_ASTC_4x4_UNORM_BLOCK;
	else if (header.blockdimX == 5 && header.blockdimY == 4) // 5x4
		*pFormat = VK_FORMAT_ASTC_5x4_UNORM_BLOCK;
	else if (header.blockdimX == 6 && header.blockdimY == 5) // 6x5
		*pFormat = VK_FORMAT_ASTC_6x5_UNORM_BLOCK;
	else if (header.blockdimX == 6 && header.blockdimY == 6) // 6x6
		*pFormat = VK_FORMAT_ASTC_6x6_UNORM_BLOCK;
	else if (header.blockdimX == 8 && header.blockdimY == 5) // 8x5
		*pFormat = VK_FORMAT_ASTC_8x5_UNORM_BLOCK;
	else if (header.blockdimX == 8 && header.blockdimY == 6) // 8x6
		*pFormat = VK_FORMAT_ASTC_8x6_UNORM_BLOCK;
	else if (header.blockdimX == 8 && header.blockdimY == 8) // 8x8
		*pFormat = VK_FORMAT_ASTC_8x8_UNORM_BLOCK;
	else if (header.blockdimX == 10 && header.blockdimY == 5) // 10x5
		*pFormat = VK_FORMAT_ASTC_10x5_UNORM_BLOCK;
	else if (header.blockdimX == 10 && header.blockdimY == 6) // 10x6
		*pFormat = VK_FORMAT_ASTC_10x6_UNORM_BLOCK;
	else if (header.blockdimX == 10 && header.blockdimY == 8) // 10x8
		*pFormat = VK_FORMAT_ASTC_10x8_UNORM_BLOCK;
	else if (header.blockdimX == 10 && header.blockdimY == 10) // 10x10
		*pFormat = VK_FORMAT_ASTC_10x10_UNORM_BLOCK;
	else if (header.blockdimX == 12 && header.blockdimY == 10) // 12x10
		*pFormat = VK_FORMAT_ASTC_12x10_UNORM_BLOCK;
	else if (header.blockdimX == 12 && header.blockdimY == 12) // 12x12
		*pFormat = VK_FORMAT_ASTC_12x12_UNORM_BLOCK;
	else
	{
		LOGE("Unknown ASTC block size %u x %u.\n", header.blockdimX, header.blockdimY);
		return RESULT_ERROR_GENERIC;
	}

	pBuffer->clear();
	pBuffer->insert(end(*pBuffer), begin(compressed) + sizeof(ASTCHeader), end(compressed));
	*pWidth = header.xsize[0] | (header.xsize[1] << 8) | (header.xsize[2] << 16);
	*pHeight = header.ysize[0] | (header.ysize[1] << 8) | (header.ysize[2] << 16);
	return RESULT_SUCCESS;
}


Texture ASTC::createASTCTextureFromAssetOrFallback(const char *pPath, const char *pFallbackPath)
{
	// We want to first create a staging buffer.
	//
	// We will then copy this buffer into an optimally tiled texture with vkCmdCopyBufferToImage.
	// The layout of such a texture is not specified as it is highly GPU-dependent and optimized for
	// utilizing texture caches better.
	unsigned width, height;
	VkFormat format;
	vector<uint8_t> buffer;

	// Check if the device supports ASTC textures.
	VkFormatProperties properties;
	vkGetPhysicalDeviceFormatProperties(pContext->getPhysicalDevice(), VK_FORMAT_ASTC_4x4_UNORM_BLOCK, &properties);
	bool supportsASTC = (properties.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) != 0;

	if (supportsASTC)
	{
		LOGI("Device supports ASTC, loading ASTC texture!\n");
		if (FAILED(loadASTCTextureFromAsset(pPath, &buffer, &width, &height, &format)))
		{
			LOGE("Failed to load texture from asset.\n");
			abort();
		}
	}
	else
	{
		LOGE("Device does not support ASTC, falling back to PNG texture!\n");
		if (FAILED(loadRgba8888TextureFromAsset(pFallbackPath, &buffer, &width, &height)))
		{
			LOGE("Failed to load fallback texture from asset.\n");
			abort();
		}
		format = VK_FORMAT_R8G8B8A8_UNORM;

		// astcenc Y-flips input PNG textures, so do the same here if we load PNG
		// textures.
		const auto flipLine = [](uint8_t *a, uint8_t *b, unsigned bytes) {
			for (unsigned i = 0; i < bytes; i++)
				std::swap(a[i], b[i]);
		};

		for (int ybegin = 0, yend = int(height) - 1; ybegin < yend; ybegin++, yend--)
			flipLine(buffer.data() + 4 * width * ybegin, buffer.data() + 4 * width * yend, width * 4);
	}

	VkDevice device = pContext->getDevice();
	VkImage image;
	VkDeviceMemory memory;

	// Copy commands such as vkCmdCopyBufferToImage will need TRANSFER_SRC_BIT.
	Buffer stagingBuffer = createBuffer(buffer.data(), buffer.size(), VK_BUFFER_USAGE_TRANSFER_SRC_BIT);

	// We will transition the actual texture into a proper layout before
	// transfering any data, so leave it as undefined.
	VkImageCreateInfo info = { VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO };
	info.imageType = VK_IMAGE_TYPE_2D;
	info.format = format;
	info.extent.width = width;
	info.extent.height = height;
	info.extent.depth = 1;
	info.mipLevels = 1;
	info.arrayLayers = 1;
	info.samples = VK_SAMPLE_COUNT_1_BIT;
	info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
	info.tiling = VK_IMAGE_TILING_OPTIMAL;
	info.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
	info.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

	// Create texture.
	VK_CHECK(vkCreateImage(device, &info, nullptr, &image));

	// Allocate memory for the texture.
	VkMemoryRequirements memReqs;
	vkGetImageMemoryRequirements(device, image, &memReqs);

	VkMemoryAllocateInfo alloc = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
	alloc.allocationSize = memReqs.size;
	// If a device local memory type exists, we should use that.
	// DEVICE_LOCAL implies that the device has the fastest possible access to
	// this resource, which is clearly what we want here.
	// On integrated GPUs such as Mali, memory types are generally *both*
	// DEVICE_LOCAL and HOST_VISIBLE at the same time,
	// since the GPU can directly access the same memory as the CPU can.
	alloc.memoryTypeIndex =
	    findMemoryTypeFromRequirementsWithFallback(memReqs.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);
	VK_CHECK(vkAllocateMemory(device, &alloc, nullptr, &memory));

	// Bind the newly allocated memory to the image.
	vkBindImageMemory(device, image, memory, 0);

	// Create an image view for the new texture.
	// Note that CreateImageView must happen after BindImageMemory.
	VkImageViewCreateInfo viewInfo = { VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO };
	viewInfo.image = image;
	viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
	viewInfo.format = format;
	viewInfo.components.r = VK_COMPONENT_SWIZZLE_R;
	viewInfo.components.g = VK_COMPONENT_SWIZZLE_G;
	viewInfo.components.b = VK_COMPONENT_SWIZZLE_B;
	viewInfo.components.a = VK_COMPONENT_SWIZZLE_A;
	viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	viewInfo.subresourceRange.levelCount = 1;
	viewInfo.subresourceRange.layerCount = 1;

	VkImageView view;
	VK_CHECK(vkCreateImageView(device, &viewInfo, nullptr, &view));

	// Now we need to transfer the staging texture into the real texture.
	// For this we will need a command buffer.
	VkCommandBuffer cmd = pContext->requestPrimaryCommandBuffer();

	// We will only submit this once before it's recycled.
	VkCommandBufferBeginInfo beginInfo = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };
	beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
	vkBeginCommandBuffer(cmd, &beginInfo);

	// Transition the uninitialized texture into a TRANSFER_DST_OPTIMAL layout.
	// We do not need to wait for anything to make the transition, so use
	// TOP_OF_PIPE_BIT as the srcStageMask.
	imageMemoryBarrier(cmd, image, 0, VK_ACCESS_TRANSFER_WRITE_BIT, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
	                   VK_PIPELINE_STAGE_TRANSFER_BIT, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);

	VkBufferImageCopy region = {};
	region.bufferOffset = 0;
	region.bufferRowLength = 0;
	region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	region.imageSubresource.layerCount = 1;
	region.imageExtent.width = width;
	region.imageExtent.height = height;
	region.imageExtent.depth = 1;

	// Copy the buffer to our optimally tiled image.
	vkCmdCopyBufferToImage(cmd, stagingBuffer.buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);

	// Wait for all transfers to complete before we let any fragment shading begin.
	imageMemoryBarrier(cmd, image, VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT,
	                   VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
	                   VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);

	VK_CHECK(vkEndCommandBuffer(cmd));
	pContext->submit(cmd);

	// We want to free the staging buffer and memory right away, so wait for GPU
	// complete the transfer.
	vkQueueWaitIdle(pContext->getGraphicsQueue());

	// Now it's safe to free the temporary resources.
	vkFreeMemory(device, stagingBuffer.memory, nullptr);
	vkDestroyBuffer(device, stagingBuffer.buffer, nullptr);

	// Finally, create a sampler.
	VkSamplerCreateInfo samplerInfo = { VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO };
	samplerInfo.magFilter = VK_FILTER_LINEAR;
	samplerInfo.minFilter = VK_FILTER_LINEAR;
	samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
	samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
	samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
	samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
	samplerInfo.mipLodBias = 0.0f;
	samplerInfo.maxAnisotropy = 1.0f;
	samplerInfo.compareEnable = false;
	samplerInfo.minLod = 0.0f;
	samplerInfo.maxLod = 0.0f;

	VkSampler sampler;
	VK_CHECK(vkCreateSampler(device, &samplerInfo, nullptr, &sampler));

	Texture ret = {
		image, view, memory, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, sampler, width, height,
	};
	return ret;
}

// Load textures.
texture4x4 = createASTCTextureFromAssetOrFallback("textures/icon-astc-4x4.astc", "textures/icon-fallback.png");
texture6x6 = createASTCTextureFromAssetOrFallback("textures/icon-astc-6x6.astc", "textures/icon-fallback.png");
texture8x8 = createASTCTextureFromAssetOrFallback("textures/icon-astc-8x8.astc", "textures/icon-fallback.png");
texture12x12 = createASTCTextureFromAssetOrFallback("textures/icon-astc-12x12.astc", "textures/icon-fallback.png");

VkDescriptorBufferInfo bufferInfo = { frame.uniformBuffer.buffer, 0, sizeof(mat4) };
VkDescriptorImageInfo imageInfos[4] = {
	{ texture4x4.sampler, texture4x4.view, texture4x4.layout },
	{ texture6x6.sampler, texture6x6.view, texture6x6.layout },
	{ texture8x8.sampler, texture8x8.view, texture8x8.layout },
	{ texture12x12.sampler, texture12x12.view, texture12x12.layout },
};

// Create one descriptor set for each texture.
for (unsigned i = 0; i < 4; i++)
{
	writes[0].dstSet = frame.descriptorSets[i];
	writes[0].dstBinding = 0;
	writes[0].descriptorCount = 1;
	writes[0].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;
	writes[0].pImageInfo = &imageInfos[i];

	writes[1].dstSet = frame.descriptorSets[i];
	writes[1].dstBinding = 1;
	writes[1].descriptorCount = 1;
	writes[1].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
	writes[1].pBufferInfo = &bufferInfo;

	vkUpdateDescriptorSets(device, 2, writes, 0, nullptr);
}

for (unsigned i = 0; i < 4; i++)
{
	const float xoff = i & 1 ? 0.5f * width : 0.0f;
	const float yoff = i & 2 ? 0.5f * height : 0.0f;

	// Viewport
	VkViewport vp = { 0 };
	vp.x = xoff;
	vp.y = yoff;
	vp.width = float(width) * 0.5f;
	vp.height = float(height) * 0.5f;
	vp.minDepth = 0.0f;
	vp.maxDepth = 1.0f;
	vkCmdSetViewport(cmd, 0, 1, &vp);

	// Scissor box
	VkRect2D scissor;
	memset(&scissor, 0, sizeof(scissor));
	scissor.offset.x = int(xoff);
	scissor.offset.y = int(yoff);
	scissor.extent.width = unsigned(vp.width);
	scissor.extent.height = unsigned(vp.height);
	vkCmdSetScissor(cmd, 0, 1, &scissor);

	// Bind the descriptor set.
	vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &frame.descriptorSets[i], 0,
	                        nullptr);

	// Draw a quad with one instance.
	vkCmdDraw(cmd, 4, 1, 0, 0);
}

<!-- saved from url=(0051)https://vulkan-tutorial.com/code/hello_triangle.cpp -->
<html><script>(function main() {
    // Create enabled event
    function fireEnabledEvent() {
        // If gli exists, then we are already present and shouldn't do anything
        if (!window.gli) {
            setTimeout(function () {
                var enabledEvent = document.createEvent("Event");
                enabledEvent.initEvent("WebGLEnabledEvent", true, true);
                document.dispatchEvent(enabledEvent);
            }, 0);
        } else {
            //console.log("WebGL Inspector already embedded on the page - disabling extension");
        }
    };

    // Grab the path root from the extension
    document.addEventListener("WebGLInspectorReadyEvent", function (e) {
        var pathElement = document.getElementById("__webglpathroot");
        if (window["gliloader"]) {
            gliloader.pathRoot = pathElement.innerText;
        } else {
            // TODO: more?
            window.gliCssUrl = pathElement.innerText + "gli.all.css";
        }
    }, false);

    // Rewrite getContext to snoop for webgl
    var originalGetContext = HTMLCanvasElement.prototype.getContext;
    if (!HTMLCanvasElement.prototype.getContextRaw) {
        HTMLCanvasElement.prototype.getContextRaw = originalGetContext;
    }
    HTMLCanvasElement.prototype.getContext = function () {
        var ignoreCanvas = this.internalInspectorSurface;
        if (ignoreCanvas) {
            return originalGetContext.apply(this, arguments);
        }

        var result = originalGetContext.apply(this, arguments);
        if (result == null) {
            return null;
        }

        var contextNames = ["moz-webgl", "webkit-3d", "experimental-webgl", "webgl", "3d"];
        var requestingWebGL = contextNames.indexOf(arguments[0]) != -1;
        if (requestingWebGL) {
            // Page is requesting a WebGL context!
            fireEnabledEvent(this);

            // If we are injected, inspect this context
            if (window.gli) {
                if (gli.host.inspectContext) {
                    // TODO: pull options from extension
                    result = gli.host.inspectContext(this, result);
                    // NOTE: execute in a timeout so that if the dom is not yet
                    // loaded this won't error out.
                    window.setTimeout(function() {
                        var hostUI = new gli.host.HostUI(result);
                        result.hostUI = hostUI; // just so we can access it later for debugging
                    }, 0);
                }
            }
        }

        return result;
    };
})();</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <link href="./hello_triangle.cpp_files/theme.min.css" rel="stylesheet">
        <link href="./hello_triangle.cpp_files/theme-blue.min.css" rel="stylesheet">
    <style type="text/css">
:root .adsbox
{ display: none !important; }</style></head>
    <body style="background: #343131">
        <script src="./hello_triangle.cpp_files/highlight.pack.js.descarga"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <pre class="cpp" style="margin: 0; padding-left: 10px"><code class="hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLFW_INCLUDE_VULKAN</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GLFW/glfw3.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> WIDTH = <span class="hljs-number">800</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> HEIGHT = <span class="hljs-number">600</span>;

<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; validationLayers = {
    <span class="hljs-string">"VK_LAYER_LUNARG_standard_validation"</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; deviceExtensions = {
    <span class="hljs-literal">VK_KHR_SWAPCHAIN_EXTENSION_NAME</span>
};

<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> NDEBUG</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enableValidationLayers = <span class="hljs-literal">false</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> enableValidationLayers = <span class="hljs-literal">true</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>

<span class="hljs-type">VkResult</span> CreateDebugReportCallbackEXT(<span class="hljs-type">VkInstance</span> instance, <span class="hljs-keyword">const</span> <span class="hljs-type">VkDebugReportCallbackCreateInfoEXT</span>* pCreateInfo, <span class="hljs-keyword">const</span> <span class="hljs-type">VkAllocationCallbacks</span>* pAllocator, <span class="hljs-type">VkDebugReportCallbackEXT</span>* pCallback) {
    <span class="hljs-keyword">auto</span> func = (PFN_<span class="hljs-function">vkCreateDebugReportCallbackEXT</span>) <span class="hljs-function">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">"vkCreateDebugReportCallbackEXT"</span>);
    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> func(instance, pCreateInfo, pAllocator, pCallback);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">VK_ERROR_EXTENSION_NOT_PRESENT</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyDebugReportCallbackEXT</span><span class="hljs-params">(VkInstance instance, VkDebugReportCallbackEXT callback, <span class="hljs-keyword">const</span> VkAllocationCallbacks* pAllocator)</span> </span>{
    <span class="hljs-keyword">auto</span> func = (PFN_<span class="hljs-function">vkDestroyDebugReportCallbackEXT</span>) <span class="hljs-function">vkGetInstanceProcAddr</span>(instance, <span class="hljs-string">"vkDestroyDebugReportCallbackEXT"</span>);
    <span class="hljs-keyword">if</span> (func != <span class="hljs-literal">nullptr</span>) {
        func(instance, callback, pAllocator);
    }
}

<span class="hljs-keyword">struct</span> <span class="hljs-type">QueueFamilyIndices</span> {
    <span class="hljs-keyword">int</span> graphicsFamily = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> presentFamily = <span class="hljs-number">-1</span>;

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isComplete</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> graphicsFamily &gt;= <span class="hljs-number">0</span> &amp;&amp; presentFamily &gt;= <span class="hljs-number">0</span>;
    }
};

<span class="hljs-keyword">struct</span> SwapChainSupportDetails {
    <span class="hljs-type">VkSurfaceCapabilitiesKHR</span> capabilities;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkSurfaceFormatKHR&gt; formats;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPresentModeKHR&gt; presentModes;
};

<span class="hljs-keyword">class</span> HelloTriangleApplication {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
        initWindow();
        initVulkan();
        mainLoop();
        cleanup();
    }

<span class="hljs-keyword">private</span>:
    GLFWwindow* window;

    <span class="hljs-type">VkInstance</span> instance;
    <span class="hljs-type">VkDebugReportCallbackEXT</span> callback;
    <span class="hljs-type">VkSurfaceKHR</span> surface;

    <span class="hljs-type">VkPhysicalDevice</span> physicalDevice = <span class="hljs-literal">VK_NULL_HANDLE</span>;
    <span class="hljs-type">VkDevice</span> device;

    <span class="hljs-type">VkQueue</span> graphicsQueue;
    <span class="hljs-type">VkQueue</span> presentQueue;

    <span class="hljs-type">VkSwapchainKHR</span> swapChain;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkImage&gt; swapChainImages;
    <span class="hljs-type">VkFormat</span> swapChainImageFormat;
    <span class="hljs-type">VkExtent2D</span> swapChainExtent;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkImageView&gt; swapChainImageViews;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkFramebuffer&gt; swapChainFramebuffers;

    <span class="hljs-type">VkRenderPass</span> renderPass;
    <span class="hljs-type">VkPipelineLayout</span> pipelineLayout;
    <span class="hljs-type">VkPipeline</span> graphicsPipeline;

    <span class="hljs-type">VkCommandPool</span> commandPool;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkCommandBuffer&gt; commandBuffers;

    <span class="hljs-type">VkSemaphore</span> imageAvailableSemaphore;
    <span class="hljs-type">VkSemaphore</span> renderFinishedSemaphore;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initWindow</span><span class="hljs-params">()</span> </span>{
        glfwInit();

        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

        window = glfwCreateWindow(WIDTH, HEIGHT, <span class="hljs-string">"Vulkan"</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initVulkan</span><span class="hljs-params">()</span> </span>{
        createInstance();
        setupDebugCallback();
        createSurface();
        pickPhysicalDevice();
        createLogicalDevice();
        createSwapChain();
        createImageViews();
        createRenderPass();
        createGraphicsPipeline();
        createFramebuffers();
        createCommandPool();
        createCommandBuffers();
        createSemaphores();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mainLoop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window)) {
            glfwPollEvents();
            drawFrame();
        }

        <span class="hljs-function">vkDeviceWaitIdle</span>(device);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-function">vkDestroySemaphore</span>(device, renderFinishedSemaphore, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroySemaphore</span>(device, imageAvailableSemaphore, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-function">vkDestroyCommandPool</span>(device, commandPool, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainFramebuffers.size(); i++) {
            <span class="hljs-function">vkDestroyFramebuffer</span>(device, swapChainFramebuffers[i], <span class="hljs-literal">nullptr</span>);
        }

        <span class="hljs-function">vkDestroyPipeline</span>(device, graphicsPipeline, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroyRenderPass</span>(device, renderPass, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.size(); i++) {
            <span class="hljs-function">vkDestroyImageView</span>(device, swapChainImageViews[i], <span class="hljs-literal">nullptr</span>);
        }

        <span class="hljs-function">vkDestroySwapchainKHR</span>(device, swapChain, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroyDevice</span>(device, <span class="hljs-literal">nullptr</span>);
        DestroyDebugReportCallbackEXT(instance, callback, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroySurfaceKHR</span>(instance, surface, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroyInstance</span>(instance, <span class="hljs-literal">nullptr</span>);

        glfwDestroyWindow(window);

        glfwTerminate();
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"validation layers requested, but not available!"</span>);
        }

        <span class="hljs-type">VkApplicationInfo</span> appInfo = {};
        appInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_APPLICATION_INFO</span>;
        appInfo.pApplicationName = <span class="hljs-string">"Hello Triangle"</span>;
        appInfo.applicationVersion = <span class="hljs-literal">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        appInfo.pEngineName = <span class="hljs-string">"No Engine"</span>;
        appInfo.engineVersion = <span class="hljs-literal">VK_MAKE_VERSION</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        appInfo.apiVersion = <span class="hljs-literal">VK_API_VERSION_1_0</span>;

        <span class="hljs-type">VkInstanceCreateInfo</span> createInfo = {};
        createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</span>;
        createInfo.pApplicationInfo = &amp;appInfo;

        <span class="hljs-keyword">auto</span> extensions = getRequiredExtensions();
        createInfo.enabledExtensionCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(extensions.size());
        createInfo.ppEnabledExtensionNames = extensions.data();

        <span class="hljs-keyword">if</span> (enableValidationLayers) {
            createInfo.enabledLayerCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(validationLayers.size());
            createInfo.ppEnabledLayerNames = validationLayers.data();
        } <span class="hljs-keyword">else</span> {
            createInfo.enabledLayerCount = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateInstance</span>(&amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;instance) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create instance!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupDebugCallback</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!enableValidationLayers) <span class="hljs-keyword">return</span>;

        <span class="hljs-type">VkDebugReportCallbackCreateInfoEXT</span> createInfo = {};
        createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT</span>;
        createInfo.flags = <span class="hljs-literal">VK_DEBUG_REPORT_ERROR_BIT_EXT</span> | <span class="hljs-literal">VK_DEBUG_REPORT_WARNING_BIT_EXT</span>;
        createInfo.pfnCallback = debugCallback;

        <span class="hljs-keyword">if</span> (CreateDebugReportCallbackEXT(instance, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;callback) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to set up debug callback!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSurface</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (glfwCreateWindowSurface(instance, window, <span class="hljs-literal">nullptr</span>, &amp;surface) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create window surface!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pickPhysicalDevice</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">uint32_t</span> deviceCount = <span class="hljs-number">0</span>;
        <span class="hljs-function">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-keyword">if</span> (deviceCount == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find GPUs with Vulkan support!"</span>);
        }

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkPhysicalDevice&gt; devices(deviceCount);
        <span class="hljs-function">vkEnumeratePhysicalDevices</span>(instance, &amp;deviceCount, devices.data());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; device : devices) {
            <span class="hljs-keyword">if</span> (isDeviceSuitable(device)) {
                physicalDevice = device;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">if</span> (physicalDevice == <span class="hljs-literal">VK_NULL_HANDLE</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to find a suitable GPU!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createLogicalDevice</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">QueueFamilyIndices</span> indices = findQueueFamilies(physicalDevice);

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt; uniqueQueueFamilies = {indices.graphicsFamily, indices.presentFamily};

        <span class="hljs-keyword">float</span> queuePriority = <span class="hljs-number">1.0f</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> queueFamily : uniqueQueueFamilies) {
            <span class="hljs-type">VkDeviceQueueCreateInfo</span> queueCreateInfo = {};
            queueCreateInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span>;
            queueCreateInfo.queueFamilyIndex = queueFamily;
            queueCreateInfo.queueCount = <span class="hljs-number">1</span>;
            queueCreateInfo.pQueuePriorities = &amp;queuePriority;
            queueCreateInfos.push_back(queueCreateInfo);
        }

        <span class="hljs-type">VkPhysicalDeviceFeatures</span> deviceFeatures = {};

        <span class="hljs-type">VkDeviceCreateInfo</span> createInfo = {};
        createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span>;

        createInfo.queueCreateInfoCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(queueCreateInfos.size());
        createInfo.pQueueCreateInfos = queueCreateInfos.data();

        createInfo.pEnabledFeatures = &amp;deviceFeatures;

        createInfo.enabledExtensionCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(deviceExtensions.size());
        createInfo.ppEnabledExtensionNames = deviceExtensions.data();

        <span class="hljs-keyword">if</span> (enableValidationLayers) {
            createInfo.enabledLayerCount = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt;(validationLayers.size());
            createInfo.ppEnabledLayerNames = validationLayers.data();
        } <span class="hljs-keyword">else</span> {
            createInfo.enabledLayerCount = <span class="hljs-number">0</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateDevice</span>(physicalDevice, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;device) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create logical device!"</span>);
        }

        <span class="hljs-function">vkGetDeviceQueue</span>(device, indices.graphicsFamily, <span class="hljs-number">0</span>, &amp;graphicsQueue);
        <span class="hljs-function">vkGetDeviceQueue</span>(device, indices.presentFamily, <span class="hljs-number">0</span>, &amp;presentQueue);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSwapChain</span><span class="hljs-params">()</span> </span>{
        SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice);

        <span class="hljs-type">VkSurfaceFormatKHR</span> surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats);
        <span class="hljs-type">VkPresentModeKHR</span> presentMode = chooseSwapPresentMode(swapChainSupport.presentModes);
        <span class="hljs-type">VkExtent2D</span> extent = chooseSwapExtent(swapChainSupport.capabilities);

        <span class="hljs-keyword">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="hljs-number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) {
            imageCount = swapChainSupport.capabilities.maxImageCount;
        }

        <span class="hljs-type">VkSwapchainCreateInfoKHR</span> createInfo = {};
        createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</span>;
        createInfo.surface = surface;

        createInfo.minImageCount = imageCount;
        createInfo.imageFormat = surfaceFormat.format;
        createInfo.imageColorSpace = surfaceFormat.colorSpace;
        createInfo.imageExtent = extent;
        createInfo.imageArrayLayers = <span class="hljs-number">1</span>;
        createInfo.imageUsage = <span class="hljs-literal">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span>;

        <span class="hljs-type">QueueFamilyIndices</span> indices = findQueueFamilies(physicalDevice);
        <span class="hljs-keyword">uint32_t</span> queueFamilyIndices[] = {(<span class="hljs-keyword">uint32_t</span>) indices.graphicsFamily, (<span class="hljs-keyword">uint32_t</span>) indices.presentFamily};

        <span class="hljs-keyword">if</span> (indices.graphicsFamily != indices.presentFamily) {
            createInfo.imageSharingMode = <span class="hljs-literal">VK_SHARING_MODE_CONCURRENT</span>;
            createInfo.queueFamilyIndexCount = <span class="hljs-number">2</span>;
            createInfo.pQueueFamilyIndices = queueFamilyIndices;
        } <span class="hljs-keyword">else</span> {
            createInfo.imageSharingMode = <span class="hljs-literal">VK_SHARING_MODE_EXCLUSIVE</span>;
        }

        createInfo.preTransform = swapChainSupport.capabilities.currentTransform;
        createInfo.compositeAlpha = <span class="hljs-literal">VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</span>;
        createInfo.presentMode = presentMode;
        createInfo.clipped = <span class="hljs-literal">VK_TRUE</span>;

        createInfo.oldSwapchain = <span class="hljs-literal">VK_NULL_HANDLE</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChain) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create swap chain!"</span>);
        }

        <span class="hljs-function">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="hljs-literal">nullptr</span>);
        swapChainImages.resize(imageCount);
        <span class="hljs-function">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.data());

        swapChainImageFormat = surfaceFormat.format;
        swapChainExtent = extent;
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createImageViews</span><span class="hljs-params">()</span> </span>{
        swapChainImageViews.resize(swapChainImages.size());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImages.size(); i++) {
            <span class="hljs-type">VkImageViewCreateInfo</span> createInfo = {};
            createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span>;
            createInfo.image = swapChainImages[i];
            createInfo.viewType = <span class="hljs-literal">VK_IMAGE_VIEW_TYPE_2D</span>;
            createInfo.format = swapChainImageFormat;
            createInfo.components.r = <span class="hljs-literal">VK_COMPONENT_SWIZZLE_IDENTITY</span>;
            createInfo.components.g = <span class="hljs-literal">VK_COMPONENT_SWIZZLE_IDENTITY</span>;
            createInfo.components.b = <span class="hljs-literal">VK_COMPONENT_SWIZZLE_IDENTITY</span>;
            createInfo.components.a = <span class="hljs-literal">VK_COMPONENT_SWIZZLE_IDENTITY</span>;
            createInfo.subresourceRange.aspectMask = <span class="hljs-literal">VK_IMAGE_ASPECT_COLOR_BIT</span>;
            createInfo.subresourceRange.baseMipLevel = <span class="hljs-number">0</span>;
            createInfo.subresourceRange.levelCount = <span class="hljs-number">1</span>;
            createInfo.subresourceRange.baseArrayLayer = <span class="hljs-number">0</span>;
            createInfo.subresourceRange.layerCount = <span class="hljs-number">1</span>;

            <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateImageView</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainImageViews[i]) != <span class="hljs-literal">VK_SUCCESS</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create image views!"</span>);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createRenderPass</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">VkAttachmentDescription</span> colorAttachment = {};
        colorAttachment.format = swapChainImageFormat;
        colorAttachment.samples = <span class="hljs-literal">VK_SAMPLE_COUNT_1_BIT</span>;
        colorAttachment.loadOp = <span class="hljs-literal">VK_ATTACHMENT_LOAD_OP_CLEAR</span>;
        colorAttachment.storeOp = <span class="hljs-literal">VK_ATTACHMENT_STORE_OP_STORE</span>;
        colorAttachment.stencilLoadOp = <span class="hljs-literal">VK_ATTACHMENT_LOAD_OP_DONT_CARE</span>;
        colorAttachment.stencilStoreOp = <span class="hljs-literal">VK_ATTACHMENT_STORE_OP_DONT_CARE</span>;
        colorAttachment.initialLayout = <span class="hljs-literal">VK_IMAGE_LAYOUT_UNDEFINED</span>;
        colorAttachment.finalLayout = <span class="hljs-literal">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</span>;

        <span class="hljs-type">VkAttachmentReference</span> colorAttachmentRef = {};
        colorAttachmentRef.attachment = <span class="hljs-number">0</span>;
        colorAttachmentRef.layout = <span class="hljs-literal">VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL</span>;

        <span class="hljs-type">VkSubpassDescription</span> subpass = {};
        subpass.pipelineBindPoint = <span class="hljs-literal">VK_PIPELINE_BIND_POINT_GRAPHICS</span>;
        subpass.colorAttachmentCount = <span class="hljs-number">1</span>;
        subpass.pColorAttachments = &amp;colorAttachmentRef;

        <span class="hljs-type">VkSubpassDependency</span> dependency = {};
        dependency.srcSubpass = <span class="hljs-literal">VK_SUBPASS_EXTERNAL</span>;
        dependency.dstSubpass = <span class="hljs-number">0</span>;
        dependency.srcStageMask = <span class="hljs-literal">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>;
        dependency.srcAccessMask = <span class="hljs-number">0</span>;
        dependency.dstStageMask = <span class="hljs-literal">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>;
        dependency.dstAccessMask = <span class="hljs-literal">VK_ACCESS_COLOR_ATTACHMENT_READ_BIT</span> | <span class="hljs-literal">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</span>;

        <span class="hljs-type">VkRenderPassCreateInfo</span> renderPassInfo = {};
        renderPassInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO</span>;
        renderPassInfo.attachmentCount = <span class="hljs-number">1</span>;
        renderPassInfo.pAttachments = &amp;colorAttachment;
        renderPassInfo.subpassCount = <span class="hljs-number">1</span>;
        renderPassInfo.pSubpasses = &amp;subpass;
        renderPassInfo.dependencyCount = <span class="hljs-number">1</span>;
        renderPassInfo.pDependencies = &amp;dependency;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="hljs-literal">nullptr</span>, &amp;renderPass) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create render pass!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createGraphicsPipeline</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">auto</span> vertShaderCode = readFile(<span class="hljs-string">"shaders/vert.spv"</span>);
        <span class="hljs-keyword">auto</span> fragShaderCode = readFile(<span class="hljs-string">"shaders/frag.spv"</span>);

        <span class="hljs-type">VkShaderModule</span> vertShaderModule = createShaderModule(vertShaderCode);
        <span class="hljs-type">VkShaderModule</span> fragShaderModule = createShaderModule(fragShaderCode);

        <span class="hljs-type">VkPipelineShaderStageCreateInfo</span> vertShaderStageInfo = {};
        vertShaderStageInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</span>;
        vertShaderStageInfo.stage = <span class="hljs-literal">VK_SHADER_STAGE_VERTEX_BIT</span>;
        vertShaderStageInfo.module = vertShaderModule;
        vertShaderStageInfo.pName = <span class="hljs-string">"main"</span>;

        <span class="hljs-type">VkPipelineShaderStageCreateInfo</span> fragShaderStageInfo = {};
        fragShaderStageInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO</span>;
        fragShaderStageInfo.stage = <span class="hljs-literal">VK_SHADER_STAGE_FRAGMENT_BIT</span>;
        fragShaderStageInfo.module = fragShaderModule;
        fragShaderStageInfo.pName = <span class="hljs-string">"main"</span>;

        <span class="hljs-type">VkPipelineShaderStageCreateInfo</span> shaderStages[] = {vertShaderStageInfo, fragShaderStageInfo};

        <span class="hljs-type">VkPipelineVertexInputStateCreateInfo</span> vertexInputInfo = {};
        vertexInputInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO</span>;
        vertexInputInfo.vertexBindingDescriptionCount = <span class="hljs-number">0</span>;
        vertexInputInfo.vertexAttributeDescriptionCount = <span class="hljs-number">0</span>;

        <span class="hljs-type">VkPipelineInputAssemblyStateCreateInfo</span> inputAssembly = {};
        inputAssembly.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO</span>;
        inputAssembly.topology = <span class="hljs-literal">VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST</span>;
        inputAssembly.primitiveRestartEnable = <span class="hljs-literal">VK_FALSE</span>;

        <span class="hljs-type">VkViewport</span> viewport = {};
        viewport.x = <span class="hljs-number">0.0f</span>;
        viewport.y = <span class="hljs-number">0.0f</span>;
        viewport.width = (<span class="hljs-keyword">float</span>) swapChainExtent.width;
        viewport.height = (<span class="hljs-keyword">float</span>) swapChainExtent.height;
        viewport.minDepth = <span class="hljs-number">0.0f</span>;
        viewport.maxDepth = <span class="hljs-number">1.0f</span>;

        <span class="hljs-type">VkRect2D</span> scissor = {};
        scissor.offset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
        scissor.extent = swapChainExtent;

        <span class="hljs-type">VkPipelineViewportStateCreateInfo</span> viewportState = {};
        viewportState.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO</span>;
        viewportState.viewportCount = <span class="hljs-number">1</span>;
        viewportState.pViewports = &amp;viewport;
        viewportState.scissorCount = <span class="hljs-number">1</span>;
        viewportState.pScissors = &amp;scissor;

        <span class="hljs-type">VkPipelineRasterizationStateCreateInfo</span> rasterizer = {};
        rasterizer.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO</span>;
        rasterizer.depthClampEnable = <span class="hljs-literal">VK_FALSE</span>;
        rasterizer.rasterizerDiscardEnable = <span class="hljs-literal">VK_FALSE</span>;
        rasterizer.polygonMode = <span class="hljs-literal">VK_POLYGON_MODE_FILL</span>;
        rasterizer.lineWidth = <span class="hljs-number">1.0f</span>;
        rasterizer.cullMode = <span class="hljs-literal">VK_CULL_MODE_BACK_BIT</span>;
        rasterizer.frontFace = <span class="hljs-literal">VK_FRONT_FACE_CLOCKWISE</span>;
        rasterizer.depthBiasEnable = <span class="hljs-literal">VK_FALSE</span>;

        <span class="hljs-type">VkPipelineMultisampleStateCreateInfo</span> multisampling = {};
        multisampling.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO</span>;
        multisampling.sampleShadingEnable = <span class="hljs-literal">VK_FALSE</span>;
        multisampling.rasterizationSamples = <span class="hljs-literal">VK_SAMPLE_COUNT_1_BIT</span>;

        <span class="hljs-type">VkPipelineColorBlendAttachmentState</span> colorBlendAttachment = {};
        colorBlendAttachment.colorWriteMask = <span class="hljs-literal">VK_COLOR_COMPONENT_R_BIT</span> | <span class="hljs-literal">VK_COLOR_COMPONENT_G_BIT</span> | <span class="hljs-literal">VK_COLOR_COMPONENT_B_BIT</span> | <span class="hljs-literal">VK_COLOR_COMPONENT_A_BIT</span>;
        colorBlendAttachment.blendEnable = <span class="hljs-literal">VK_FALSE</span>;

        <span class="hljs-type">VkPipelineColorBlendStateCreateInfo</span> colorBlending = {};
        colorBlending.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO</span>;
        colorBlending.logicOpEnable = <span class="hljs-literal">VK_FALSE</span>;
        colorBlending.logicOp = <span class="hljs-literal">VK_LOGIC_OP_COPY</span>;
        colorBlending.attachmentCount = <span class="hljs-number">1</span>;
        colorBlending.pAttachments = &amp;colorBlendAttachment;
        colorBlending.blendConstants[<span class="hljs-number">0</span>] = <span class="hljs-number">0.0f</span>;
        colorBlending.blendConstants[<span class="hljs-number">1</span>] = <span class="hljs-number">0.0f</span>;
        colorBlending.blendConstants[<span class="hljs-number">2</span>] = <span class="hljs-number">0.0f</span>;
        colorBlending.blendConstants[<span class="hljs-number">3</span>] = <span class="hljs-number">0.0f</span>;

        <span class="hljs-type">VkPipelineLayoutCreateInfo</span> pipelineLayoutInfo = {};
        pipelineLayoutInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</span>;
        pipelineLayoutInfo.setLayoutCount = <span class="hljs-number">0</span>;
        pipelineLayoutInfo.pushConstantRangeCount = <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="hljs-literal">nullptr</span>, &amp;pipelineLayout) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create pipeline layout!"</span>);
        }

        <span class="hljs-type">VkGraphicsPipelineCreateInfo</span> pipelineInfo = {};
        pipelineInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO</span>;
        pipelineInfo.stageCount = <span class="hljs-number">2</span>;
        pipelineInfo.pStages = shaderStages;
        pipelineInfo.pVertexInputState = &amp;vertexInputInfo;
        pipelineInfo.pInputAssemblyState = &amp;inputAssembly;
        pipelineInfo.pViewportState = &amp;viewportState;
        pipelineInfo.pRasterizationState = &amp;rasterizer;
        pipelineInfo.pMultisampleState = &amp;multisampling;
        pipelineInfo.pColorBlendState = &amp;colorBlending;
        pipelineInfo.layout = pipelineLayout;
        pipelineInfo.renderPass = renderPass;
        pipelineInfo.subpass = <span class="hljs-number">0</span>;
        pipelineInfo.basePipelineHandle = <span class="hljs-literal">VK_NULL_HANDLE</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateGraphicsPipelines</span>(device, <span class="hljs-literal">VK_NULL_HANDLE</span>, <span class="hljs-number">1</span>, &amp;pipelineInfo, <span class="hljs-literal">nullptr</span>, &amp;graphicsPipeline) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create graphics pipeline!"</span>);
        }

        <span class="hljs-function">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="hljs-literal">nullptr</span>);
        <span class="hljs-function">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="hljs-literal">nullptr</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createFramebuffers</span><span class="hljs-params">()</span> </span>{
        swapChainFramebuffers.resize(swapChainImageViews.size());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; swapChainImageViews.size(); i++) {
            <span class="hljs-type">VkImageView</span> attachments[] = {
                swapChainImageViews[i]
            };

            <span class="hljs-type">VkFramebufferCreateInfo</span> framebufferInfo = {};
            framebufferInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO</span>;
            framebufferInfo.renderPass = renderPass;
            framebufferInfo.attachmentCount = <span class="hljs-number">1</span>;
            framebufferInfo.pAttachments = attachments;
            framebufferInfo.width = swapChainExtent.width;
            framebufferInfo.height = swapChainExtent.height;
            framebufferInfo.layers = <span class="hljs-number">1</span>;

            <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateFramebuffer</span>(device, &amp;framebufferInfo, <span class="hljs-literal">nullptr</span>, &amp;swapChainFramebuffers[i]) != <span class="hljs-literal">VK_SUCCESS</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create framebuffer!"</span>);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCommandPool</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">QueueFamilyIndices</span> queueFamilyIndices = findQueueFamilies(physicalDevice);

        <span class="hljs-type">VkCommandPoolCreateInfo</span> poolInfo = {};
        poolInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span>;
        poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="hljs-literal">nullptr</span>, &amp;commandPool) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create command pool!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createCommandBuffers</span><span class="hljs-params">()</span> </span>{
        commandBuffers.resize(swapChainFramebuffers.size());

        <span class="hljs-type">VkCommandBufferAllocateInfo</span> allocInfo = {};
        allocInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span>;
        allocInfo.commandPool = commandPool;
        allocInfo.level = <span class="hljs-literal">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span>;
        allocInfo.commandBufferCount = (<span class="hljs-keyword">uint32_t</span>) commandBuffers.size();

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, commandBuffers.data()) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to allocate command buffers!"</span>);
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; commandBuffers.size(); i++) {
            <span class="hljs-type">VkCommandBufferBeginInfo</span> beginInfo = {};
            beginInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO</span>;
            beginInfo.flags = <span class="hljs-literal">VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT</span>;

            <span class="hljs-function">vkBeginCommandBuffer</span>(commandBuffers[i], &amp;beginInfo);

            <span class="hljs-type">VkRenderPassBeginInfo</span> renderPassInfo = {};
            renderPassInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO</span>;
            renderPassInfo.renderPass = renderPass;
            renderPassInfo.framebuffer = swapChainFramebuffers[i];
            renderPassInfo.renderArea.offset = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>};
            renderPassInfo.renderArea.extent = swapChainExtent;

            <span class="hljs-type">VkClearValue</span> clearColor = {<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>};
            renderPassInfo.clearValueCount = <span class="hljs-number">1</span>;
            renderPassInfo.pClearValues = &amp;clearColor;

            <span class="hljs-function">vkCmdBeginRenderPass</span>(commandBuffers[i], &amp;renderPassInfo, <span class="hljs-literal">VK_SUBPASS_CONTENTS_INLINE</span>);

                <span class="hljs-function">vkCmdBindPipeline</span>(commandBuffers[i], <span class="hljs-literal">VK_PIPELINE_BIND_POINT_GRAPHICS</span>, graphicsPipeline);

                <span class="hljs-function">vkCmdDraw</span>(commandBuffers[i], <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

            <span class="hljs-function">vkCmdEndRenderPass</span>(commandBuffers[i]);

            <span class="hljs-keyword">if</span> (<span class="hljs-function">vkEndCommandBuffer</span>(commandBuffers[i]) != <span class="hljs-literal">VK_SUCCESS</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to record command buffer!"</span>);
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createSemaphores</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-type">VkSemaphoreCreateInfo</span> semaphoreInfo = {};
        semaphoreInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;imageAvailableSemaphore) != <span class="hljs-literal">VK_SUCCESS</span> ||
            <span class="hljs-function">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="hljs-literal">nullptr</span>, &amp;renderFinishedSemaphore) != <span class="hljs-literal">VK_SUCCESS</span>) {

            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create semaphores!"</span>);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFrame</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">uint32_t</span> imageIndex;
        <span class="hljs-function">vkAcquireNextImageKHR</span>(device, swapChain, <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">uint64_t</span>&gt;::max(), imageAvailableSemaphore, <span class="hljs-literal">VK_NULL_HANDLE</span>, &amp;imageIndex);

        <span class="hljs-type">VkSubmitInfo</span> submitInfo = {};
        submitInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_SUBMIT_INFO</span>;

        <span class="hljs-type">VkSemaphore</span> waitSemaphores[] = {imageAvailableSemaphore};
        <span class="hljs-type">VkPipelineStageFlags</span> waitStages[] = {<span class="hljs-literal">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</span>};
        submitInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;
        submitInfo.pWaitSemaphores = waitSemaphores;
        submitInfo.pWaitDstStageMask = waitStages;

        submitInfo.commandBufferCount = <span class="hljs-number">1</span>;
        submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex];

        <span class="hljs-type">VkSemaphore</span> signalSemaphores[] = {renderFinishedSemaphore};
        submitInfo.signalSemaphoreCount = <span class="hljs-number">1</span>;
        submitInfo.pSignalSemaphores = signalSemaphores;

        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkQueueSubmit</span>(graphicsQueue, <span class="hljs-number">1</span>, &amp;submitInfo, <span class="hljs-literal">VK_NULL_HANDLE</span>) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to submit draw command buffer!"</span>);
        }

        <span class="hljs-type">VkPresentInfoKHR</span> presentInfo = {};
        presentInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_PRESENT_INFO_KHR</span>;

        presentInfo.waitSemaphoreCount = <span class="hljs-number">1</span>;
        presentInfo.pWaitSemaphores = signalSemaphores;

        <span class="hljs-type">VkSwapchainKHR</span> swapChains[] = {swapChain};
        presentInfo.swapchainCount = <span class="hljs-number">1</span>;
        presentInfo.pSwapchains = swapChains;

        presentInfo.pImageIndices = &amp;imageIndex;

        <span class="hljs-function">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);

        <span class="hljs-function">vkQueueWaitIdle</span>(presentQueue);
    }

    <span class="hljs-type">VkShaderModule</span> createShaderModule(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt;&amp; code) {
        <span class="hljs-type">VkShaderModuleCreateInfo</span> createInfo = {};
        createInfo.sType = <span class="hljs-literal">VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO</span>;
        createInfo.codeSize = code.size();
        createInfo.pCode = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span>*&gt;(code.data());

        <span class="hljs-type">VkShaderModule</span> shaderModule;
        <span class="hljs-keyword">if</span> (<span class="hljs-function">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="hljs-literal">nullptr</span>, &amp;shaderModule) != <span class="hljs-literal">VK_SUCCESS</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to create shader module!"</span>);
        }

        <span class="hljs-keyword">return</span> shaderModule;
    }

    <span class="hljs-type">VkSurfaceFormatKHR</span> chooseSwapSurfaceFormat(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">VkSurfaceFormatKHR</span>&gt;&amp; availableFormats) {
        <span class="hljs-keyword">if</span> (availableFormats.size() == <span class="hljs-number">1</span> &amp;&amp; availableFormats[<span class="hljs-number">0</span>].format == <span class="hljs-literal">VK_FORMAT_UNDEFINED</span>) {
            <span class="hljs-keyword">return</span> {<span class="hljs-literal">VK_FORMAT_B8G8R8A8_UNORM</span>, <span class="hljs-literal">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</span>};
        }

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; availableFormat : availableFormats) {
            <span class="hljs-keyword">if</span> (availableFormat.format == <span class="hljs-literal">VK_FORMAT_B8G8R8A8_UNORM</span> &amp;&amp; availableFormat.colorSpace == <span class="hljs-literal">VK_COLOR_SPACE_SRGB_NONLINEAR_KHR</span>) {
                <span class="hljs-keyword">return</span> availableFormat;
            }
        }

        <span class="hljs-keyword">return</span> availableFormats[<span class="hljs-number">0</span>];
    }

    <span class="hljs-type">VkPresentModeKHR</span> chooseSwapPresentMode(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">VkPresentModeKHR</span>&gt; availablePresentModes) {
        <span class="hljs-type">VkPresentModeKHR</span> bestMode = <span class="hljs-literal">VK_PRESENT_MODE_FIFO_KHR</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; availablePresentMode : availablePresentModes) {
            <span class="hljs-keyword">if</span> (availablePresentMode == <span class="hljs-literal">VK_PRESENT_MODE_MAILBOX_KHR</span>) {
                <span class="hljs-keyword">return</span> availablePresentMode;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (availablePresentMode == <span class="hljs-literal">VK_PRESENT_MODE_IMMEDIATE_KHR</span>) {
                bestMode = availablePresentMode;
            }
        }

        <span class="hljs-keyword">return</span> bestMode;
    }

    <span class="hljs-type">VkExtent2D</span> chooseSwapExtent(<span class="hljs-keyword">const</span> <span class="hljs-type">VkSurfaceCapabilitiesKHR</span>&amp; capabilities) {
        <span class="hljs-keyword">if</span> (capabilities.currentExtent.width != <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">uint32_t</span>&gt;::max()) {
            <span class="hljs-keyword">return</span> capabilities.currentExtent;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-type">VkExtent2D</span> actualExtent = {WIDTH, HEIGHT};

            actualExtent.width = <span class="hljs-built_in">std</span>::max(capabilities.minImageExtent.width, <span class="hljs-built_in">std</span>::min(capabilities.maxImageExtent.width, actualExtent.width));
            actualExtent.height = <span class="hljs-built_in">std</span>::max(capabilities.minImageExtent.height, <span class="hljs-built_in">std</span>::min(capabilities.maxImageExtent.height, actualExtent.height));

            <span class="hljs-keyword">return</span> actualExtent;
        }
    }

    <span class="hljs-function">SwapChainSupportDetails <span class="hljs-title">querySwapChainSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
        SwapChainSupportDetails details;

        <span class="hljs-function">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;details.capabilities);

        <span class="hljs-keyword">uint32_t</span> formatCount;
        <span class="hljs-function">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-keyword">if</span> (formatCount != <span class="hljs-number">0</span>) {
            details.formats.resize(formatCount);
            <span class="hljs-function">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.data());
        }

        <span class="hljs-keyword">uint32_t</span> presentModeCount;
        <span class="hljs-function">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-keyword">if</span> (presentModeCount != <span class="hljs-number">0</span>) {
            details.presentModes.resize(presentModeCount);
            <span class="hljs-function">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, details.presentModes.data());
        }

        <span class="hljs-keyword">return</span> details;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isDeviceSuitable</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
        <span class="hljs-type">QueueFamilyIndices</span> indices = findQueueFamilies(device);

        <span class="hljs-keyword">bool</span> extensionsSupported = checkDeviceExtensionSupport(device);

        <span class="hljs-keyword">bool</span> swapChainAdequate = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (extensionsSupported) {
            SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device);
            swapChainAdequate = !swapChainSupport.formats.empty() &amp;&amp; !swapChainSupport.presentModes.empty();
        }

        <span class="hljs-keyword">return</span> indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkDeviceExtensionSupport</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
        <span class="hljs-keyword">uint32_t</span> extensionCount;
        <span class="hljs-function">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkExtensionProperties&gt; availableExtensions(extensionCount);
        <span class="hljs-function">vkEnumerateDeviceExtensionProperties</span>(device, <span class="hljs-literal">nullptr</span>, &amp;extensionCount, availableExtensions.data());

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; requiredExtensions(deviceExtensions.begin(), deviceExtensions.end());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; extension : availableExtensions) {
            requiredExtensions.erase(extension.extensionName);
        }

        <span class="hljs-keyword">return</span> requiredExtensions.empty();
    }

    <span class="hljs-function"><span class="hljs-type">QueueFamilyIndices</span> <span class="hljs-title">findQueueFamilies</span><span class="hljs-params">(VkPhysicalDevice device)</span> </span>{
        <span class="hljs-type">QueueFamilyIndices</span> indices;

        <span class="hljs-keyword">uint32_t</span> queueFamilyCount = <span class="hljs-number">0</span>;
        <span class="hljs-function">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
        <span class="hljs-function">vkGetPhysicalDeviceQueueFamilyProperties</span>(device, &amp;queueFamilyCount, queueFamilies.data());

        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; queueFamily : queueFamilies) {
            <span class="hljs-keyword">if</span> (queueFamily.queueCount &gt; <span class="hljs-number">0</span> &amp;&amp; queueFamily.queueFlags &amp; <span class="hljs-literal">VK_QUEUE_GRAPHICS_BIT</span>) {
                indices.graphicsFamily = i;
            }

            <span class="hljs-type">VkBool32</span> presentSupport = <span class="hljs-literal">false</span>;
            <span class="hljs-function">vkGetPhysicalDeviceSurfaceSupportKHR</span>(device, i, surface, &amp;presentSupport);

            <span class="hljs-keyword">if</span> (queueFamily.queueCount &gt; <span class="hljs-number">0</span> &amp;&amp; presentSupport) {
                indices.presentFamily = i;
            }

            <span class="hljs-keyword">if</span> (indices.isComplete()) {
                <span class="hljs-keyword">break</span>;
            }

            i++;
        }

        <span class="hljs-keyword">return</span> indices;
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; getRequiredExtensions() {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; extensions;

        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> glfwExtensionCount = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>** glfwExtensions;
        glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; glfwExtensionCount; i++) {
            extensions.push_back(glfwExtensions[i]);
        }

        <span class="hljs-keyword">if</span> (enableValidationLayers) {
            extensions.push_back(<span class="hljs-literal">VK_EXT_DEBUG_REPORT_EXTENSION_NAME</span>);
        }

        <span class="hljs-keyword">return</span> extensions;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkValidationLayerSupport</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">uint32_t</span> layerCount;
        <span class="hljs-function">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, <span class="hljs-literal">nullptr</span>);

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;VkLayerProperties&gt; availableLayers(layerCount);
        <span class="hljs-function">vkEnumerateInstanceLayerProperties</span>(&amp;layerCount, availableLayers.data());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* layerName : validationLayers) {
            <span class="hljs-keyword">bool</span> layerFound = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; layerProperties : availableLayers) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(layerName, layerProperties.layerName) == <span class="hljs-number">0</span>) {
                    layerFound = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (!layerFound) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; readFile(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename) {
        <span class="hljs-built_in">std</span>::<span class="hljs-function">ifstream <span class="hljs-title">file</span><span class="hljs-params">(filename, <span class="hljs-built_in">std</span>::ios::ate | <span class="hljs-built_in">std</span>::ios::binary)</span></span>;

        <span class="hljs-keyword">if</span> (!file.is_open()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::runtime_error(<span class="hljs-string">"failed to open file!"</span>);
        }

        <span class="hljs-keyword">size_t</span> fileSize = (<span class="hljs-keyword">size_t</span>) file.tellg();
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; buffer(fileSize);

        file.seekg(<span class="hljs-number">0</span>);
        file.read(buffer.data(), fileSize);

        file.close();

        <span class="hljs-keyword">return</span> buffer;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> VKAPI_ATTR VkBool32 VKAPI_CALL <span class="hljs-title">debugCallback</span><span class="hljs-params">(VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objType, <span class="hljs-keyword">uint64_t</span> obj, <span class="hljs-keyword">size_t</span> location, <span class="hljs-keyword">int32_t</span> code, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* layerPrefix, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* msg, <span class="hljs-keyword">void</span>* userData)</span> </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"validation layer: "</span> &lt;&lt; msg &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-literal">VK_FALSE</span>;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    HelloTriangleApplication app;

    <span class="hljs-keyword">try</span> {
        app.run();
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::runtime_error&amp; e) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span> EXIT_FAILURE;
    }

    <span class="hljs-keyword">return</span> EXIT_SUCCESS;
}
</code></pre>
    
</body></html>
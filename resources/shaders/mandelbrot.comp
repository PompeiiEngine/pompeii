#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout( local_size_x = 32,local_size_y = 32, local_size_z = 1 ) in;
layout( binding = 0, rgba16 ) uniform writeonly image2D resultImage;

// Code based in https://www.shadertoy.com/view/4df3Rn

layout(binding = 1) uniform UniformBufferObject
{
    float time;
};

void mandelbrot( out vec4 fragColor, in vec2 p )
{
    vec3 col = vec3(0.0);
     
    float zoo = 0.62 + 0.38*cos(.07*time);
    float coa = cos( 0.15*(1.0-zoo)*time );
    float sia = sin( 0.15*(1.0-zoo)*time );
    zoo = pow( zoo,8.0);
    vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);
    vec2 c = vec2(-.745,.186) + xy*zoo;

    const float B = 256.0;
    float l = 0.0;
    vec2 z  = vec2(0.0);
    for( int i = 0; i < 200; ++i )
    {
		// z = z*z + c		
		z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;

		if( dot(z,z)>(B*B) ) break;

		l += 1.0;
 	}

	// ------------------------------------------------------
	// smooth interation count
	float sl = l - log(log(length(z))/log(B))/log(2.0);
	// ------------------------------------------------------

	float al = smoothstep( -0.1, 0.0, sin(0.5*6.2831*time ) );
	l = mix( l, sl, al );

	col += 0.5 + 0.5*cos( 3.0 + l*0.15 + vec3(0.0,0.6,1.0));

	fragColor = vec4( col, 1.0 );

	//fragColor = vec4( p, 0.0, 1.0);
}

void main( )
{
	vec4 fragColor = vec4 (0.0, 0.0, 0.0, 1.0);
	ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);

	
	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
	
	vec2 old_uv = uv;
	old_uv.y = 1.0 - old_uv.y;
	vec2 new_uv = -1.0 + 2.0 * old_uv;
	
	mandelbrot( fragColor, new_uv );
	
	imageStore( resultImage, pixel_coords, fragColor );
}
#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

#define INFINITY 100000.0
const float epsilon = 1e-3;

struct Sphere
{
    vec3 center;
    float radius;
    vec3 color;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
} ray;

struct Light
{
    vec3 position;
    float ambience;
};

struct RayTracerOutput
{
    Ray reflectedRay;
    vec3 color;
};

layout (binding = 1) uniform UBO 
{
	Light light;
};

layout( binding = 2 ) buffer SphereBuffer
{
	//Sphere spheres[];
	Sphere sp[];
};

Sphere spheres[5];

float getIntersection( int i, Ray ray)
{
	Sphere sphere = spheres[ i ];
    vec3 sphereCenter = sphere.center;
    vec3 colorOfSphere = sphere.color;
    float radius = sphere.radius;
    vec3 cameraSource = ray.origin;
    vec3 cameraDirection = ray.direction;

    vec3 distanceFromCenter = (cameraSource - sphereCenter);
    float B = 2.0 * dot(cameraDirection, distanceFromCenter);
    float C = dot(distanceFromCenter, distanceFromCenter) - pow(radius, 2.0);
    float delta = pow(B, 2.0) - 4.0 * C;
    float t = 0.0;
    if (delta > 0.0) {
        float sqRoot = sqrt(delta);
        float t1 = (-B + sqRoot) / 2.0;
        float t2 = (-B - sqRoot) / 2.0;
        t = min(t1, t2);
    }
    if (delta == 0.0) {
        t = -B / 2.0;
    }
    return t;
}

RayTracerOutput trace( Ray ray )
{
	RayTracerOutput rayTracer;
    Ray reflectionRay;
    Sphere sphereToShow;
    float minT = INFINITY;
    vec3 cameraSource = ray.origin;
    vec3 cameraDirection = ray.direction;
    vec3 lightSource = light.position;
    float ambience = light.ambience;
    vec3 color = vec3(0.0, 0.0, 0.0);

	int numSpheres = 5;//spheres.length();
    for (int i=0; i < numSpheres; ++i) {
        float t = getIntersection( i, ray );
        if (t > 0.0 && t < minT) {
            minT = t;
            sphereToShow = spheres[i];
        }
    }

    vec3 sphereCenter = sphereToShow.center;
    vec3 colorOfSphere = sphereToShow.color;

    if (minT > 0.0 && minT != INFINITY) {
        vec3 surfacePoint = cameraSource + (minT * cameraDirection);
        vec3 surfaceNormal = normalize(surfacePoint - sphereCenter);

        // Reflection
        vec3 reflection = 2.0 * dot(-ray.direction, surfaceNormal) * surfaceNormal + ray.direction;
        reflectionRay.origin = surfaceNormal + epsilon * reflection;
        reflectionRay.direction = reflection;
        color = colorOfSphere * (ambience + ((1.0 - ambience) * max(0.0, dot(surfaceNormal, lightSource))));
        rayTracer.color = color;
        rayTracer.reflectedRay = reflectionRay;
    }
    return rayTracer;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	ray.origin = vec3( 0.0, 0.0, 4.0 );
	ray.direction = normalize(vec3(fragCoord.x, fragCoord.y, -1.0)); 

	RayTracerOutput rayTracer = trace(ray);
    // Second call to get reflections
    RayTracerOutput reflection = trace(rayTracer.reflectedRay);
    fragColor = vec4(rayTracer.color + reflection.color, 1.0);
}

const float A = 0.15;
const float B = 0.50;
const float C = 0.10;
const float D = 0.20;
const float E = 0.02;
const float F = 0.30;
const float W = 11.2;

vec3 Uncharted2Tonemap(vec3 x)
{
   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

//Based on Filmic Tonemapping Operators http://filmicgames.com/archives/75
vec3 tonemapUncharted2(vec3 color)
{
    float ExposureBias = 2.0;
    vec3 curr = Uncharted2Tonemap(ExposureBias * color);

    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));
    return curr * whiteScale;
}

void main( )
{
	spheres[0] = Sphere( 
		vec3( 0.25,   1.5, -0.25 ),  
		0.3, 
      	vec3( 1.0, 0.0, 0.0 ) 
  	);
    spheres[1] = Sphere( 
    	vec3(  0.5,  0.25,  0.75 ),  
    	0.2, 
      	vec3( 0.0, 1.0, 0.0 ) 
  	);
    spheres[2] = Sphere( 
    	vec3( -0.75,  0.0,   0.5 ),  
    	0.2, 
      	vec3( 0.0, 0.0, 1.0 ) 
  	);
    spheres[3] = Sphere( 
    	vec3( -0.25,  0.4,   0.1 ),
    	0.25, 
      	vec3( 0.0, 1.0, 1.0 ) 
  	);
    spheres[4] = Sphere( 
    	vec3(  -1.5, 0.15,  0.15 ),
    	0.35, 
      	vec3( 1.0, 1.0, 0.0 ) 
  	);

	ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	vec4 fragColor;

	mainImage( fragColor, uv );

	//fragColor.rgb = tonemapUncharted2( fragColor.rgb );

	imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), fragColor);
}